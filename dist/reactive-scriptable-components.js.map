{"version":3,"file":"reactive-scriptable-components.js","sources":["../src/reactive-scriptable-components.ts"],"sourcesContent":["/*******************************************************************************\n*                                                                              *\n*           Reactive Scriptable Components (RSC, pronounced \"resc\")            *\n*                                                                              *\n*******************************************************************************/\n\nimport * as JIL from 'javascript-interface-library'\n\nimport {\n  throwError,\n  quoted,\n  ObjectIsEmpty,\n  ValueIsBoolean,\n  ValueIsNumber, ValueIsNumberInRange, ValueIsInteger, ValueIsIntegerInRange,\n  ValueIsString, ValueIsStringMatching, ValueIsTextline, ValueIsText,\n  ValueIsFunction,\n  ValueIsObject, ValueIsArray,\n  ValueIsListSatisfying,\n  ValueIsURL,\n  ValidatorForClassifier, acceptNil, rejectNil,\n  expectTextline, expectedTextline,\n  expectFunction,\n  allowListSatisfying,\n  expectInstanceOf,\n} from 'javascript-interface-library'\n\nimport { render, html, Component } from 'htm/preact'\n\nimport hyperactiv from 'hyperactiv'\nconst { observe, computed, dispose } = hyperactiv\n\n/**** hide all undefined custom elements (to avoid initial flashing) ****/\n\n  const Stylesheet = document.createElement('style')\n    Stylesheet.innerHTML = ':not(:defined) { visibility:hidden }'\n  document.head.appendChild(Stylesheet)\n\n/**** make some existing types indexable ****/\n\n  interface Indexable { [Key:string]:any }\n\n  type indexableFunction    = Function    & Indexable\n  type indexableElement     = Element     & Indexable\n  type indexableHTMLElement = HTMLElement & Indexable\n  type indexableEvent       = Event       & Indexable\n\nnamespace RSC {\n//------------------------------------------------------------------------------\n//--                             Type Definitions                             --\n//------------------------------------------------------------------------------\n\n  export type Textline = string              // mainly for illustrative purposes\n  export type Text     = string                                          // dto.\n  export type URL      = string                                          // dto.\n\n  export type RSC_Name = string                                          // dto.\n\n/**** throwReadOnlyError ****/\n\n  export function throwReadOnlyError (Name:string):never {\n    throwError(\n      'ReadOnlyProperty: property ' + quoted(Name) + ' must not be set'\n    )\n  }\n\n//------------------------------------------------------------------------------\n//--                 Classification and Validation Functions                  --\n//------------------------------------------------------------------------------\n\n/**** ValueIsDOMElement ****/\n\n  export function ValueIsDOMElement (Value:any):boolean {\n    return (Value instanceof Element)\n  }\n\n/**** allow/expect[ed]DOMElement ****/\n\n  export const allowDOMElement = ValidatorForClassifier(\n    ValueIsDOMElement, acceptNil, 'DOM element'\n  ), allowedDOMElement = allowDOMElement\n\n  export const expectDOMElement = ValidatorForClassifier(\n    ValueIsDOMElement, rejectNil, 'DOM element'\n  ), expectedDOMElement = expectDOMElement\n\n/**** ValueIsVisual ****/\n\n  export function ValueIsVisual (Value:any):boolean {\n    return (Value instanceof RSC_Visual)\n  }\n\n/**** allow/expect[ed]Visual ****/\n\n  export const allowVisual = ValidatorForClassifier(\n    ValueIsVisual, acceptNil, 'RSC visual'\n  ), allowedVisual = allowVisual\n\n  export const expectVisual = ValidatorForClassifier(\n    ValueIsVisual, rejectNil, 'RSC visual'\n  ), expectedVisual = expectVisual\n\n/**** ValueIsName ****/\n\n  const RSC_NamePattern = /^[a-z$_][a-z$_0-9]*(-[a-z$_0-9]+)*$/i\n\n  export function ValueIsName (Value:any):boolean {\n    return ValueIsStringMatching(Value, RSC_NamePattern)\n  }\n\n/**** allow/expect[ed]Name ****/\n\n  export const allowName = ValidatorForClassifier(\n    ValueIsName, acceptNil, 'RSC name'\n  ), allowedName = allowName\n\n  export const expectName = ValidatorForClassifier(\n    ValueIsName, rejectNil, 'RSC name'\n  ), expectedName = expectName\n\n/**** ValueIsErrorInfo ****/\n\n  export function ValueIsErrorInfo (Value:any):boolean {\n    return (\n      ValueIsObject(Value) &&\n      ValueIsTextline(Value.Title) &&\n      ValueIsText(Value.Message)\n    )\n  }\n\n/**** allow/expect[ed]ErrorInfo ****/\n\n  export const allowErrorInfo = ValidatorForClassifier(\n    ValueIsErrorInfo, acceptNil, 'RSC error information record'\n  ), allowedErrorInfo = allowErrorInfo\n\n  export const expectErrorInfo = ValidatorForClassifier(\n    ValueIsErrorInfo, rejectNil, 'RSC error information record'\n  ), expectedErrorInfo = expectErrorInfo\n\n//------------------------------------------------------------------------------\n//--                        Value Acceptance Functions                        --\n//------------------------------------------------------------------------------\n\n/**** acceptableBoolean ****/\n\n  export function acceptableBoolean (Value:any, Default:boolean):boolean {\n    return (ValueIsBoolean(Value) ? Value : Default)\n  }\n\n/**** acceptableNumber ****/\n\n  export function acceptableNumber (Value:any, Default:number) {\n    return (ValueIsNumber(Value) ? Value : Default)\n  }\n\n/**** acceptableNumberInRange ****/\n\n  export function acceptableNumberInRange (\n    Value:any, Default:number,\n    minValue:number = -Infinity, maxValue:number = Infinity,\n    withMin:boolean = false, withMax:boolean = false\n  ) {\n    return (\n      ValueIsNumberInRange(Value,minValue,maxValue,withMin,withMax) ? Value : Default\n    )\n  }\n\n/**** acceptableInteger ****/\n\n  export function acceptableInteger (Value:any, Default:number) {\n    return (ValueIsInteger(Value) ? Value : Default)\n  }\n\n/**** acceptableIntegerInRange ****/\n\n  export function acceptableIntegerInRange (\n    Value:any, Default:number,\n    minValue:number = -Infinity, maxValue:number = Infinity\n  ) {\n    return (ValueIsIntegerInRange(Value,minValue,maxValue) ? Value : Default)\n  }\n\n/**** acceptableString ****/\n\n  export function acceptableString (Value:any, Default:string) {\n    return (ValueIsString(Value) ? Value : Default)\n  }\n\n/**** acceptableNonEmptyString ****/\n\n  export function acceptableNonEmptyString (Value:any, Default:string) {\n    return (ValueIsString(Value) && (Value.trim() !== '') ? Value : Default)\n  }\n\n/**** acceptableStringMatching ****/\n\n  export function acceptableStringMatching (\n    Value:any, Default:string, Pattern:RegExp\n  ) {\n    return (ValueIsStringMatching(Value,Pattern) ? Value : Default)\n  }\n\n/**** acceptableURL ****/\n\n  export function acceptableURL (Value:any, Default:URL):URL {\n    return (ValueIsURL(Value) ? Value : Default)\n  }\n\n//------------------------------------------------------------------------------\n//--                      Initialization Marker Handling                      --\n//------------------------------------------------------------------------------\n\n  const InitializationMarkerForVisual:WeakMap<RSC_Visual,boolean> = new WeakMap()\n\n/**** VisualWasInitialized ****/\n\n  function VisualWasInitialized (Visual:RSC_Visual):boolean {\n    return (InitializationMarkerForVisual.get(Visual) === true)\n  }\n\n/**** markVisualAsInitialized ****/\n\n  function markVisualAsInitialized (Visual:RSC_Visual):void {\n    InitializationMarkerForVisual.set(Visual,true)\n  }\n\n//------------------------------------------------------------------------------\n//--                           Containment Handling                           --\n//------------------------------------------------------------------------------\n\n/**** outerVisualOf ****/\n\n  export function outerVisualOf (DOMElement:HTMLElement):RSC_Visual|undefined {\n    expectDOMElement('element',DOMElement)\n\n    DOMElement = DOMElement.parentElement as HTMLElement\n    while (DOMElement != null) {\n      if (ValueIsVisual(DOMElement)) {\n        return DOMElement as RSC_Visual\n      }\n      DOMElement = DOMElement.parentElement as HTMLElement\n    }\n\n    return undefined\n  }\n\n  export const VisualContaining = outerVisualOf\n\n/**** outermostVisualOf ****/\n\n  export function outermostVisualOf (DOMElement:HTMLElement):RSC_Visual|undefined {\n    expectDOMElement('element',DOMElement)\n\n    let outermostVisual:RSC_Visual|undefined = undefined\n      DOMElement = DOMElement.parentElement as HTMLElement\n      while (DOMElement != null) {\n        if (ValueIsVisual(DOMElement)) {\n          outermostVisual = DOMElement as RSC_Visual\n        }\n        DOMElement = DOMElement.parentElement as HTMLElement\n      }\n    return outermostVisual\n  }\n\n/**** closestVisualWithBehaviour ****/\n\n  export function closestVisualWithBehaviour (\n    DOMElement:HTMLElement, BehaviourName:RSC_Name\n  ):RSC_Visual|undefined {\n    expectDOMElement ('element',DOMElement)\n    expectName('behaviour name',BehaviourName)\n\n    const normalizedName = BehaviourName.toLowerCase()\n    while (DOMElement != null) {\n      if (\n        ValueIsVisual(DOMElement) &&\n        ((BehaviourNameOfVisual(DOMElement as RSC_Visual) || '').toLowerCase() === normalizedName)\n      ) {\n        return DOMElement as RSC_Visual\n      }\n      DOMElement = outerVisualOf(DOMElement) as HTMLElement\n    }\n    return undefined\n  }\n\n/**** closestVisualMatching ****/\n\n  export function closestVisualMatching (\n    DOMElement:HTMLElement, Selector:Textline\n  ):RSC_Visual|undefined {\n    expectDOMElement   ('element',DOMElement)\n    expectTextline('CSS selector',Selector)\n\n    while (DOMElement != null) {\n      if (ValueIsVisual(DOMElement) && DOMElement.matches(Selector)) {\n        return DOMElement as RSC_Visual\n      }\n      DOMElement = outerVisualOf(DOMElement) as HTMLElement\n    }\n    return undefined\n  }\n\n/**** innerElementsOf ****/\n\n  function innerElementsOf (DOMElement:HTMLElement):Element[] {\n    return Array.from(DOMElement.children)\n  }\n\n/**** innerVisualsOf ****/\n\n  export function innerVisualsOf (DOMElement:HTMLElement):RSC_Visual[] {\n    expectDOMElement('element',DOMElement)\n\n    const innerVisuals = Array.from(DOMElement.children)\n      .filter((innerElement) => ValueIsVisual(innerElement))\n    return innerVisuals as RSC_Visual[]\n  }\n\n//------------------------------------------------------------------------------\n//--                           Behaviour Management                           --\n//------------------------------------------------------------------------------\n\n  type RSC_BehaviourInfo = {\n    Name:RSC_Name,\n    AttributeSet:{[normalizedName:RSC_Name]:RSC_Name},\n    Source?:Text,\n    Executable?:Function,\n    Error?:RSC_ErrorInfo\n  }\n\n  type RSC_BehaviourRegistry = {\n    [normalizedName:RSC_Name]:RSC_BehaviourInfo\n  }\n\n/**** Behaviours are global ****/\n\n  const BehaviourRegistry:RSC_BehaviourRegistry = Object.create(null)\n\n/**** InfoForBehaviour ****/\n\n  function InfoForBehaviour (Name:RSC_Name):RSC_BehaviourInfo|undefined {\n    return BehaviourRegistry[Name.toLowerCase()]\n  }\n\n/**** registerBehaviour ****/\n\n  function registerBehaviour (\n    Name:RSC_Name, SourceOrExecutable:Text|Function,\n    observedAttributes:RSC_Name[] = []\n  ):void {\n    let normalizedName = Name.toLowerCase()\n\n    allowListSatisfying(\n      'list of observed element attributes', observedAttributes, ValueIsName\n    )\n\n    const AttributeSet = Object.create(null)\n    if (observedAttributes != null) {\n      observedAttributes.forEach(\n        (Name) => AttributeSet[Name.toLowerCase()] = Name\n      )\n      observedAttributes = observedAttributes.map((Name) => Name.toLowerCase())\n    }\n\n    if (ValueIsFunction(SourceOrExecutable)) {\n      BehaviourRegistry[normalizedName] = {\n        Name, AttributeSet, Executable:SourceOrExecutable as Function\n      }\n    } else {\n      if (normalizedName in BehaviourRegistry) {\n        const BehaviourInfo = BehaviourRegistry[normalizedName]\n        if (BehaviourInfo.Source == null) throwError(\n          'ForbiddenOperation: cannot overwrite intrinsic behaviour ' + quoted(Name)\n        )\n\n        if (BehaviourInfo.Source.trim() !== (SourceOrExecutable as Text).trim()) throwError(\n          'ForbiddenOperation: cannot overwrite existing behaviour ' + quoted(Name)\n        )\n      } else {\n        let Source = SourceOrExecutable as Text\n\n        let Executable:Function\n        try {\n          Executable = compiledScript(Source)\n        } catch (Signal) {\n          console.error(\n            `CompilationError: compilation of behaviour ${quoted(Name)} failed. ` +\n            'Reason: ' + Signal\n          )\n\n          BehaviourRegistry[normalizedName] = {\n            Name, AttributeSet, Source, Error:{\n              Title:'Compilation Failure',\n              Message:`Compilation of behaviour ${quoted(Name)} failed.\\n\\n` +\n                'Reason:' + Signal\n            }\n          }\n          return\n        }\n\n        BehaviourRegistry[normalizedName] = {\n          Name, AttributeSet, Source, Executable\n        }\n      }\n    }\n\n  /**** install a custom element for the given behaviour ****/\n\n    const customizedVisual = class extends RSC_Visual {\n      static observedAttributes:string[] = observedAttributes\n    }\n    customElements.define('rsc-' + normalizedName, customizedVisual)\n  }\n\n  BehaviourRegistry['visual'] = {\n    Name:'Visual', AttributeSet:{ value:'Value' }\n  }\n\n/**** registerBehaviourFromElement ****/\n\n  function registerBehaviourFromElement (ScriptElement:Element):void {\n    let Name = expectedName(\n      'behaviour name',ScriptElement.getAttribute('for-behaviour')\n    )\n    if (Name.toLowerCase() === 'visual') throwError(\n      'ReservedName: behaviour name \"visual\" is reserved for internal use'\n    )\n\n    let Source = ScriptElement.innerHTML\n\n    let observedAttributes:RSC_Name[] = (\n      (ScriptElement.getAttribute('observed-attributes') || '')\n      .split(/\\s*(?:,|$)\\s*/).filter((Name) => (Name || '').trim() !== '')\n    )\n    if (! ValueIsListSatisfying(observedAttributes,ValueIsName)) throwError(\n      'Invalidargument: attribute \"observed-attributes\" does not contain a ' +\n      'list of valid RSC attribute names'\n    )\n\n    registerBehaviour(Name,Source,observedAttributes)\n\n    permitVisualsWithinBehaviour(\n      Name, ScriptElement.getAttribute('permitted-contents') || ''\n    )\n\n    forbidVisualsWithinBehaviour(\n      Name, ScriptElement.getAttribute('fobidden-contents') || ''\n    )\n  }\n\n/**** registerAllBehavioursFoundInHead ****/\n\n  function registerAllBehavioursFoundInHead ():void {\n    innerElementsOf(document.head).forEach((Element) => {\n      if (Element.matches('script[type=\"rsc-script\"][for-behaviour]')) {\n        registerBehaviourFromElement(Element)\n      }\n    })\n  }\n\n/**** registerAllBehavioursFoundInVisual ****/\n\n  function registerAllBehavioursFoundInVisual (Visual:RSC_Visual):void {\n    innerElementsOf(Visual).forEach((Element) => {\n      if (Element.matches('script[type=\"rsc-script\"][for-behaviour]')) {\n        registerBehaviourFromElement(Element)\n      }\n    })\n  }\n\n//registerAllBehavioursFoundInHead()           // not yet, only after RSC_Visual\n\n/**** BehaviourNameOfVisual ****/\n\n  function BehaviourNameOfVisual (Visual:RSC_Visual):RSC_Name|undefined {\n    let BehaviourName = Visual.tagName.slice(4).toLowerCase()\n    if (BehaviourName === 'visual') {\n      BehaviourName = Visual.getAttribute('behaviour') as string\n      return (ValueIsName(BehaviourName) ? BehaviourName : 'visual')\n    } else {\n      return InfoForBehaviour(BehaviourName)?.Name || BehaviourName\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                    Content and Containment Validation                    --\n//------------------------------------------------------------------------------\n\n  type RSC_SelectorSet = {[BehaviourName:RSC_Name]:string}\n\n  const permittedVisualsSelectorWithinBehaviour:RSC_SelectorSet = Object.create(null)\n  const forbiddenVisualsSelectorWithinBehaviour:RSC_SelectorSet = Object.create(null)\n\n/**** permitVisualsWithinBehaviour ****/\n\n  function permitVisualsWithinBehaviour (\n    BehaviourName:RSC_Name, Selector:string\n  ):void {\n    Selector = Selector.trim()\n    if (Selector !== '') {\n      const normalizedBehaviourName = BehaviourName.toLowerCase()\n      permittedVisualsSelectorWithinBehaviour[normalizedBehaviourName] = Selector\n    }\n  }\n\n/**** forbidVisualsWithinBehaviour ****/\n\n  function forbidVisualsWithinBehaviour (\n    BehaviourName:RSC_Name, Selector:string\n  ):void {\n    Selector = Selector.trim()\n    if (Selector !== '') {\n      const normalizedBehaviourName = BehaviourName.toLowerCase()\n      forbiddenVisualsSelectorWithinBehaviour[normalizedBehaviourName] = Selector\n    }\n  }\n\n/**** validateContentsOfVisual ****/\n\n  function validateContentsOfVisual (Visual:RSC_Visual):void {\n    const BehaviourName = BehaviourNameOfVisual(Visual)\n    if (BehaviourName == null) { return }\n\n    const normalizedBehaviourName = BehaviourName.toLowerCase()\n    let permittedVisualsSelector = permittedVisualsSelectorWithinBehaviour[normalizedBehaviourName]\n    let forbiddenVisualsSelector = forbiddenVisualsSelectorWithinBehaviour[normalizedBehaviourName]\n\n    if ((permittedVisualsSelector != null) || (forbiddenVisualsSelector != null)) {\n      innerVisualsOf(Visual).forEach((innerVisual) => {\n        if ((\n          (permittedVisualsSelector != null) &&\n          ! innerVisual.matches(permittedVisualsSelector)\n        ) || (\n          (forbiddenVisualsSelector != null) &&\n          innerVisual.matches(forbiddenVisualsSelector)\n        )) {\n          innerVisual.remove()\n        }\n      })\n    }\n  }\n\n/**** validateContainerOfVisual ****/\n\n  function validateContainerOfVisual (Visual:RSC_Visual):void {\n    const Container = outerVisualOf(Visual)\n    if (Container == null) { return }\n\n    const BehaviourName = BehaviourNameOfVisual(Container)\n    if (BehaviourName == null) { return }\n\n    const normalizedBehaviourName = BehaviourName.toLowerCase()\n\n    let permittedVisualsSelector = permittedVisualsSelectorWithinBehaviour[normalizedBehaviourName]\n    if (permittedVisualsSelector != null) {\n      if (! Visual.matches(permittedVisualsSelector)) throwError(\n        'InacceptableInnerVisual: the given visual is not allowed to become a ' +\n        'part of its container'\n      )\n    }\n\n    let forbiddenVisualsSelector = forbiddenVisualsSelectorWithinBehaviour[normalizedBehaviourName]\n    if (forbiddenVisualsSelector != null) {\n      if (Visual.matches(forbiddenVisualsSelector)) throwError(\n        'InacceptableInnerVisual: the given visual is not allowed to become a ' +\n        'part of its container'\n      )\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                       Script Delegation Management                       --\n//------------------------------------------------------------------------------\n\n  type RSC_Selector = Textline\n\n  type RSC_ScriptDelegationInfo = {\n    Selector:RSC_Selector,\n    Source:Text,\n    Executable:Function,\n    Error?:RSC_ErrorInfo\n  }\n\n  type RSC_ScriptDelegationSet = {[Selector:RSC_Selector]:RSC_ScriptDelegationInfo}\n\n  const ScriptDelegationSetForVisual:WeakMap<RSC_Visual,RSC_ScriptDelegationSet> = new WeakMap()\n\n/**** registerDelegatedScriptInVisual ****/\n\n  function registerDelegatedScriptInVisual (\n    Visual:RSC_Visual, Selector:RSC_Selector, Source:Text\n  ):void {\n    let ScriptDelegationSet = ScriptDelegationSetForVisual.get(Visual)\n    if (ScriptDelegationSet == null) {\n      ScriptDelegationSetForVisual.set(Visual,ScriptDelegationSet = Object.create(null))\n    }\n\n    if (Selector in (ScriptDelegationSet as RSC_ScriptDelegationSet)) throwError(\n      'ForbiddenOperation: a script for elements matching selector ' +\n      quoted(Selector) + ' exists already'\n    )\n\n    let Executable:Function\n    try {\n      Executable = compiledScript(Source)\n    } catch (Signal) {\n      throwError(\n        'CompilationError: compilation of delegated script for elements ' +\n        'matching selector ' + quoted(Selector) + ' failed. ' +\n        'Reason: ' + Signal\n      )\n    }\n\n    (ScriptDelegationSet as RSC_ScriptDelegationSet)[Selector] = { Selector, Source, Executable }\n  }\n\n/**** registerDelegatedScriptFromElement ****/\n\n  function registerDelegatedScriptFromElement (\n    Visual:RSC_Visual, ScriptElement:Element\n  ):void {\n    let Selector = expectedTextline(\n      'element selector',ScriptElement.getAttribute('for')\n    )\n\n    let Script = ScriptElement.innerHTML\n\n    registerDelegatedScriptInVisual(Visual, Selector, Script)\n  }\n\n/**** registerAllDelegatedScriptsFoundInVisual ****/\n\n  function registerAllDelegatedScriptsFoundInVisual (Visual:RSC_Visual):void {\n    innerElementsOf(Visual).forEach((Element) => {\n      if (Element.matches('script[type=\"rsc-script\"][for]')) {\n        registerDelegatedScriptFromElement(Visual,Element)\n      }\n    })\n  }\n\n/**** delegatedScriptInfoForVisual ****/\n\n  function delegatedScriptInfoForVisual (\n    Visual:RSC_Visual\n  ):RSC_ScriptDelegationInfo|undefined {\n    let ScriptContainer = Visual\n    while (ScriptContainer != null) {\n      let ScriptDelegationSet = ScriptDelegationSetForVisual.get(ScriptContainer)\n      if (ScriptDelegationSet != null) {\n        for (const Selector in ScriptDelegationSet) {\n          if (Visual.matches(Selector)) {\n            return ScriptDelegationSet[Selector]\n          }\n        }\n      }\n\n      ScriptContainer = outerVisualOf(ScriptContainer) as RSC_Visual\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                             Script Handling                              --\n//------------------------------------------------------------------------------\n\n/**** ScriptOfVisual ****/\n\n  function ScriptOfVisual (Visual:RSC_Visual):Text|undefined {\n    let Script = Visual.getAttribute('script') || ''\n    return (Script.trim() === '' ? undefined : Script)\n  }\n\n/**** ScriptInVisual ****/\n\n  function ScriptInVisual (Visual:RSC_Visual):Text|undefined {\n    const ScriptList = innerElementsOf(Visual)\n    for (let i = 0, l = ScriptList.length; i < l; i++) {\n      let Candidate = ScriptList[i]\n      if (\n        (Candidate.tagName === 'SCRIPT') &&\n        ((Candidate.getAttribute('type') || '') === 'rsc-script') &&\n        ! Candidate.hasAttribute('for') && ! Candidate.hasAttribute('for-behaviour')\n      ) { return Candidate.innerHTML }\n    }\n  }\n\n/**** compiledScript - throws on failure ****/\n\n  function compiledScript (Script:Text):Function {\n    return new Function(\n      'RSC,JIL, onAttributeChange, onAttachment,onDetachment, toRender,' +\n      'html, on,once,off,trigger, reactively',\n      Script || ''\n    )                                                                // may fail!\n  }\n\n/**** applyExecutable - throws on failure ****/\n\n  function applyExecutable (Visual:RSC_Visual, Executable:Function):void {\n    const onAttributeChange = Visual.onAttributeChange.bind(Visual)\n    const onAttachment      = Visual.onAttachment     .bind(Visual)\n    const onDetachment      = Visual.onDetachment     .bind(Visual)\n    const toRender          = Visual.toRender         .bind(Visual)\n\n  /**** on ****/\n\n    function on (\n      Events:string, SelectorOrHandler:string|String|null|Function,\n      DataOrHandler?:any, Handler?:Function\n    ):void {\n      registerEventHandlerForVisual(\n        Visual, Events,SelectorOrHandler,DataOrHandler,Handler\n      )\n    }\n\n  /**** once ****/\n\n    function once (\n      Events:string, SelectorOrHandler:string|String|null|Function,\n      DataOrHandler?:any, Handler?:Function\n    ):void {\n      registerEventHandlerForVisual(\n        Visual, Events,SelectorOrHandler,DataOrHandler,Handler, 'once'\n      )\n    }\n\n  /**** off ****/\n\n    function off (\n      Events?:string, SelectorOrHandler?:string|String|null|Function,\n      Handler?:Function\n    ):void {\n      let ArgList = Array.prototype.slice.call(arguments,1)\n\n      Events = (Events || '').trim().replace(/\\s+/g,' ')\n      if (Events === '') {\n        unregisterAllMatchingEventHandlersFromVisual(Visual)\n        return\n      }\n\n      let Selector:string = (\n        ValueIsString(ArgList[0])\n        ? (ArgList.shift() as string).trim()\n        : (ArgList[0] === null ? ArgList.shift() || '' : undefined)\n      )          // \"null\" means: no selector, \"undefined\" means: any selector\n\n      Handler = ArgList.shift()\n      if (Handler == null) {\n        unregisterAllMatchingEventHandlersFromVisual(Visual,Events,Selector)\n      } else {\n        unregisterAllMatchingEventHandlersFromVisual(Visual,Events,Selector,Handler)\n      }\n    }\n\n  /**** trigger ****/\n\n    function trigger (\n      EventToTrigger:string|Event, Arguments:any[],\n      bubbles = true\n    ):boolean {\n      Arguments = (ValueIsArray(Arguments) ? Arguments.slice() : [])\n\n      switch (true) {\n        case ValueIsString(EventToTrigger):\n          EventToTrigger = new CustomEvent(\n            EventToTrigger as string, {\n              bubbles, cancelable:true, detail:{ Arguments }\n            }\n          )\n          break\n        case (EventToTrigger instanceof Event):\n          EventToTrigger = new CustomEvent((EventToTrigger as Event).type,\n            Object.assign({}, EventToTrigger, {\n              bubbles, cancelable:true , detail:{ Arguments }\n            })\n          )\n          break\n        default: debugger; throwError(\n          'InvalidArgument: Event instance or literal event type expected'\n        )\n      }\n\n      Visual.dispatchEvent(EventToTrigger as CustomEvent)\n\n      const EventDetails = (EventToTrigger as CustomEvent).detail\n      if (EventDetails?.Error == null) {\n        return EventDetails?.Result\n      } else {\n        throw EventDetails?.Error\n      }\n    }\n\n  /**** reactively ****/\n\n    function reactively (reactiveFunction:Function) {\n      expectFunction('reactive function',reactiveFunction)\n// @ts-ignore we definitely want the function argument to be accepted\n      registerReactiveFunctionIn(Visual,computed(reactiveFunction))\n    }\n\n  /**** run \"Executable\" in the context of \"Visual\" ****/\n\n    Executable.apply(Visual, [\n      RSC,JIL, onAttributeChange, onAttachment,onDetachment, toRender,\n      html, on,once,off,trigger, reactively\n    ])\n  }\n\n/**** applyBehaviourScriptOfVisual ****/\n\n  function applyBehaviourScriptOfVisual (Visual:RSC_Visual):void {\n    const BehaviourName = BehaviourNameOfVisual(Visual)\n    if (BehaviourName == null) { return }\n\n    const BehaviourInfo = InfoForBehaviour(BehaviourName)\n    if (BehaviourInfo == null) {\n      setErrorOfVisual(Visual,{\n        Title:'Missing Behaviour',\n        Message:'Behaviour ' + quoted(BehaviourName) + ' could not be found'\n      })\n      return\n    }\n\n    if (BehaviourInfo.Error != null) {\n      setErrorOfVisual(Visual,BehaviourInfo.Error)\n      return\n    }\n\n    const Executable = BehaviourInfo.Executable as Function\n    if (Executable == null) { return }\n\n    try {\n      applyExecutable(Visual,Executable)\n    } catch (Signal) {\nconsole.error(Signal)\n      setErrorOfVisual(Visual,{\n        Title:'Execution Failure',\n        Message:'Script of behaviour ' + quoted(BehaviourName) + ' could not ' +\n                'be executed.\\n\\nReason:\\n' + Signal\n      })\n      return\n    }\n  }\n\n/**** applyElementScriptOfVisual ****/\n\n  function applyElementScriptOfVisual (Visual:RSC_Visual):void {\n    const Script = ScriptOfVisual(Visual) || ScriptInVisual(Visual)\n    if (Script != null) {\n      let Executable\n      try {\n        Executable = compiledScript(Script)\n      } catch (Signal) {\nconsole.error(Signal)\n        setErrorOfVisual(Visual,{\n          Title:'Compilation Failure',\n          Message:'Visual script could not be compiled.\\n\\nReason:\\n' + Signal\n        })\n      }\n\n      try {\n        applyExecutable(Visual,Executable as Function)\n      } catch (Signal) {\nconsole.error(Signal)\n        setErrorOfVisual(Visual,{\n          Title:'Execution Failure',\n          Message:'Visual script could not be executed.\\n\\nReason:\\n' + Signal\n        })\n      }\n      return\n    }\n\n    const ScriptDelegationInfo = delegatedScriptInfoForVisual(Visual)\n    if (ScriptDelegationInfo != null) {\n      if (ScriptDelegationInfo.Error != null) {\n        setErrorOfVisual(Visual,ScriptDelegationInfo.Error)\n        return\n      }\n\n      try {\n        applyExecutable(Visual,ScriptDelegationInfo.Executable)\n      } catch (Signal) {\nconsole.error(Signal)\n        setErrorOfVisual(Visual,{\n          Title:'Execution Failure',\n          Message:'delegated visual script with selector ' +\n            quoted(ScriptDelegationInfo.Selector) + ' could not be ' +\n            'executed.\\n\\nReason:\\n' + Signal\n        })\n        return\n      }\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                              Event Handling                              --\n//------------------------------------------------------------------------------\n\n/**** ValueIsEventNameWithSelector ****/\n\n  const RSC_NameWithSelectorPattern = /^[a-z$_][a-z$_0-9]*([-.:][a-z$_0-9]+)*@.*$/i\n\n  function ValueIsEventNameWithSelector (Value:any):boolean {\n    return ValueIsStringMatching(Value,RSC_NameWithSelectorPattern)\n  }\n\n/**** registerEventHandlerForVisual ****/\n\n  function registerEventHandlerForVisual (\n    Visual:RSC_Visual,\n    Events:string, SelectorOrHandler?:string|String|null|Function,\n    DataOrHandler?:any, Handler?:Function, once?:'once'\n  ):void {\n    let ArgList = Array.prototype.slice.call(arguments,1)\n\n    Events = ArgList.shift().trim().replace(/\\s+/g,' ')\n    if (Events === '') { return }\n\n    let Selector:string = (\n      ValueIsString(ArgList[0])\n      ? (ArgList.shift() as string).trim()\n      : (ArgList[0] == null ? ArgList.shift() || '' : '')\n    )                                                   // '' means: no selector\n\n    let Data:any = (\n      typeof ArgList[1] === 'function'\n      ? ArgList.shift()\n      : undefined\n    )\n\n    Handler = ArgList.shift() as Function\n\n    _registerEventHandlerForVisual(\n      Visual, Events,Selector,Data,Handler, once\n    )\n  }\n\n/**** _registerEventHandlerForVisual ****/\n\n  const EventRegistryForVisual:WeakMap<RSC_Visual,object> = new WeakMap()\n\n  function _registerEventHandlerForVisual (\n    Visual:RSC_Visual,\n    Events:string, Selector:string|String, Data:any,\n    Handler:Function, once?:'once'\n  ):void {\n  /**** actualHandler ****/\n\n    function actualHandler (Event:indexableEvent):void {\n      switch (Selector) {\n        case '':\n          break\n        case '@this':\n          if (Event.target !== Event.currentTarget) { return }\n          break\n        default:\n          if (! (Event.target as Element).matches(Selector as string)) { return }\n      }\n\n      if (Data != null) { Event.data = Data }\n\n      if (once) {\n        unregisterAllMatchingEventHandlersFromVisual(\n          Visual, Event.type,Selector,Handler\n        )\n      }\n\n      let ArgList = [Event].concat(Event.detail?.Arguments || [])\n      try {\n        const Result = Handler.apply(Visual,ArgList)\n        if (Result !== undefined) {\n          ;(Event.detail || {}).Result = Result\n\n          Event.stopImmediatePropagation()\n          Event.preventDefault()\n        }\n      } catch (Signal) {\n        ;(Event.detail || {}).Error = Signal\n\n        Event.stopImmediatePropagation()\n        Event.preventDefault()\n      }\n    }\n    (actualHandler as indexableFunction)['isFor'] = Handler\n\n    let EventList:string[]\n    if (ValueIsEventNameWithSelector(Events)) {\n      let AtIndex = Events.indexOf('@')\n      EventList = [Events.slice(0,AtIndex)]\n      Selector  = Events.slice(AtIndex+1)\n        if (Selector === 'this') { Selector = '@this' }          // special case\n    } else {\n      EventList = Events.split(' ')\n    }\n\n    let EventRegistry:Indexable = EventRegistryForVisual.get(Visual) as Indexable\n    if (EventRegistry == null) {\n      EventRegistryForVisual.set(Visual,EventRegistry = Object.create(null))\n    }\n\n    EventList.forEach((Event) => {\n      let EntriesForEvent:Indexable = (EventRegistry as Indexable)[Event]\n      if (EntriesForEvent == null) {\n        EntriesForEvent = (EventRegistry as Indexable)[Event] = Object.create(null)\n      }\n\n      let EntriesForSelector:Function[] = EntriesForEvent[Selector as string]\n      if (EntriesForSelector == null) {\n        EntriesForSelector = EntriesForEvent[Selector as string] = []\n      }\n\n      EntriesForSelector.push(actualHandler)\n      Visual.addEventListener(Event,actualHandler)\n    })\n  }\n\n/**** unregisterAllMatchingEventHandlersFromVisual ****/\n\n  function unregisterAllMatchingEventHandlersFromVisual (\n    Visual:RSC_Visual,\n    Events?:string, Selector?:string|String|null, Handler?:Function\n  ):void {\n    let EventList:string[]\n    if (ValueIsEventNameWithSelector(Events)) {\n      let AtIndex = (Events as string).indexOf('@')\n      EventList = [(Events as string).slice(0,AtIndex)]\n      Selector  = (Events as string).slice(AtIndex+1)\n    } else {\n      EventList = (Events == null ? [] : Events.split(' '))\n    }\n\n    const EventRegistry = EventRegistryForVisual.get(Visual)\n    if (EventRegistry == null) { return }\n\n    if (EventList.length === 0) {               // unregister any event handlers\n      for (let Event in EventRegistry) {\n        unregisterMatchingEventHandlersFromVisual(\n          Visual, Event,Selector,Handler\n        )\n      }\n    } else {                    // unregister handlers for the given events only\n      EventList.forEach((Event:string) => {\n        unregisterMatchingEventHandlersFromVisual(\n          Visual, Event,Selector,Handler\n        )\n      })\n    }\n  }\n\n/**** unregisterMatchingEventHandlersFromVisual ****/\n\n  function unregisterMatchingEventHandlersFromVisual (\n    Visual:RSC_Visual,\n    Event:string, Selector?:string|String|null, Handler?:Function\n  ):void {\n    const EventRegistry:Indexable = EventRegistryForVisual.get(Visual) as Indexable\n    if (EventRegistry == null) { return }\n\n    let EntriesForEvent:Indexable = EventRegistry[Event]\n    if (EntriesForEvent != null) {\n      if (Selector == null) {\n        for (let Selector in EntriesForEvent) {\n          unregisterMatchingEventSelectorHandlersFromVisual(\n            Visual, EntriesForEvent, Event,Selector,Handler\n          )\n        }\n      } else {\n        unregisterMatchingEventSelectorHandlersFromVisual(\n          Visual, EntriesForEvent, Event,Selector,Handler\n        )\n      }\n\n      if (ObjectIsEmpty(EntriesForEvent)) {\n        delete EventRegistry[Event]\n      }\n    }\n  }\n\n/**** unregisterMatchingEventSelectorHandlersFromVisual ****/\n\n  function unregisterMatchingEventSelectorHandlersFromVisual (\n    Visual:RSC_Visual,\n    EntriesForEvent:any, Event:string, Selector:string|String, Handler?:Function\n  ):void {\n    let EntriesForSelector:Function[] = EntriesForEvent[Selector as string]\n    if (EntriesForSelector != null) {\n      if (Handler == null) {\n        EntriesForSelector.forEach((actualHandler:Function) => {\n// @ts-ignore TypeScript does not allow JS functions here, but that's wrong\n          Visual.removeEventListener(Event,actualHandler)\n        })\n        EntriesForSelector.length = 0\n      } else {\n        EntriesForSelector.every((actualHandler:indexableFunction, Index:number) => {\n          if (actualHandler['isFor'] === Handler) {\n// @ts-ignore TypeScript does not allow JS functions here, but that's wrong\n            Visual.removeEventListener(Event,actualHandler)\n            EntriesForSelector.splice(Index,1)\n            return false\n          }\n          return true\n        })\n      }\n\n      if (EntriesForSelector.length === 0) {\n        delete EntriesForEvent[Selector as string]\n      }\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                           Reactivity Handling                            --\n//------------------------------------------------------------------------------\n\n  const reactiveFunctionsForVisual:WeakMap<RSC_Visual,Function[]>  = new WeakMap()\n  const reactiveAttributesForVisual:WeakMap<RSC_Visual,Function[]> = new WeakMap()\n\n/**** ObservableOfVisual ****/\n\n  const ObservableForVisual:WeakMap<RSC_Visual,Indexable> = new WeakMap()\n\n  function ObservableOfVisual (Visual:RSC_Visual):Indexable {\n    let Observable = ObservableForVisual.get(Visual)\n    if (Observable == null) {\n      ObservableForVisual.set(Visual, Observable = observe({},{ deep:false }))\n    }\n    return Observable as Indexable\n  }\n\n/**** UnobservedOfVisual ****/\n\n  const UnobservedForVisual:WeakMap<RSC_Visual,Indexable> = new WeakMap()\n\n  function UnobservedOfVisual (Visual:RSC_Visual):Indexable {\n    let Unobserved = UnobservedForVisual.get(Visual)\n    if (Unobserved == null) {\n      UnobservedForVisual.set(Visual, Unobserved = {})\n    }\n    return Unobserved as Indexable\n  }\n\n/**** startReactiveRenderingOfVisual ****/\n\n  const reactiveRendererForVisual:WeakMap<RSC_Visual,Function> = new WeakMap()\n\n  function startReactiveRenderingOfVisual (Visual:RSC_Visual):void {\n    reactiveRendererForVisual.set(Visual,computed(Visual.render.bind(Visual)))\n  }\n\n/**** stopReactiveRenderingOfVisual ****/\n\n  function stopReactiveRenderingOfVisual (Visual:RSC_Visual):void {\n    const Renderer = reactiveRendererForVisual.get(Visual)\n    if (Renderer != null) {\n      dispose(Renderer)\n      reactiveRendererForVisual.delete(Visual)\n    }\n  }\n\n/**** ValueIsReactiveAttributeName ****/\n\n  function ValueIsReactiveAttributeName (Value:any):boolean {\n    return (\n      ValueIsString(Value) && (\n        Value.startsWith('$')  && ValueIsName(Value.slice(1)) ||\n        Value.startsWith('$$') && ValueIsName(Value.slice(2))\n      )\n    )\n  }\n\n/**** updateAttributeOfVisual (non-reactive attributes only) ****/\n\n  function updateAttributeOfVisual (\n    Visual:RSC_Visual, normalizedName:RSC_Name, newValue:string|undefined\n  ):void {\n    let AttributeChangeHandler = AttributeChangeHandlerForVisual.get(Visual)\n    if (AttributeChangeHandler == null) {\n      const BehaviourName = BehaviourNameOfVisual(Visual)\n      if (BehaviourName == null) { return }\n\n      const Behaviour = InfoForBehaviour(BehaviourName)\n      if (Behaviour == null) { return }\n\n      const AttributeSet = Behaviour.AttributeSet\n      if (normalizedName in AttributeSet) {\n        const originalName = AttributeSet[normalizedName]\n        try {\n          Visual.observed[originalName] = newValue\n        } catch (Signal) {\n          setErrorOfVisual(Visual,{\n            Title:'Attribute Change Failure',\n            Message:(\n              'could not update observed property \"' +\n              quoted(originalName) + '\" upon a change of attribute \"' +\n              quoted(normalizedName) + '\"'\n            )\n          })\n        }\n      }\n    } else {\n      try {\n        AttributeChangeHandler.call(Visual, normalizedName, newValue)\n      } catch (Signal) {\n        setErrorOfVisual(Visual,{\n          Title:'Attribute Change Handler Failure',\n          Message:'Running the configured attribute change handler failed\\n\\n' +\n                  'Reason: ' + Signal\n        })\n      }\n    }\n  }\n\n/**** updateAllAttributesOfVisual (non-reactive attributes only) ****/\n\n  function updateAllAttributesOfVisual (Visual:RSC_Visual):void {\n    Array.from(Visual.attributes).forEach((Attribute) => {\n      const normalizedName = Attribute.name\n      if (ValueIsName(normalizedName)) {      // ignores all reactive attributes\n        updateAttributeOfVisual(Visual,normalizedName,Attribute.value)\n      }\n    })\n  }\n\n/**** registerAllReactiveAttributesOfVisual ****/\n\n  function registerAllReactiveAttributesOfVisual (Visual:RSC_Visual):void {\n    Array.from(Visual.attributes).forEach((Attribute) => {\n      const reactiveName = Attribute.name\n      if (ValueIsReactiveAttributeName(reactiveName)) {\n        const BehaviourName = BehaviourNameOfVisual(Visual)\n        if (BehaviourName == null) { return }\n\n        const Behaviour = InfoForBehaviour(BehaviourName)\n        if (Behaviour == null) { return }\n\n        const normalizedName = reactiveName.replace(/^[$]{1,2}/,'')\n\n        const AttributeSet = Behaviour.AttributeSet\n        if (normalizedName in AttributeSet) {\n          const originalName = AttributeSet[normalizedName]\n\n          const { Base,PathList } = parsedAccessPathFromVisual(\n            Visual, Attribute.value\n          )\n\n          let HandlerList:Function[] = reactiveAttributesForVisual.get(Visual) as Function[]\n          if (HandlerList == null) {\n            reactiveAttributesForVisual.set(Visual,HandlerList = [])\n          }\n\n          if (reactiveName.startsWith('$$')) {\n            const Handler = computed(() => {\n              setValueOfReactiveVariable(\n                Base, PathList, Visual.observed[originalName]\n              )\n            })\n            HandlerList.push(Handler)\n          }\n\n          const Handler = computed(() => {\n            Visual.observed[originalName] = ValueOfReactiveVariable(Base, PathList)\n          })\n          HandlerList.push(Handler)\n        }\n      }\n    })\n  }\n\n/**** parsedAccessPathFromVisual ****/\n\n  type RSC_AccessPath = {\n    Base:RSC_Visual,\n    PathList:string[]\n  }\n\n  const    dottedIndexPattern = /^\\s*[.]([^.\\[]+)/\n  const  unquotedIndexPattern = /^\\s*\\[([^'\"\\]]+)\\]/\n  const sglquotedIndexPattern = /^\\s*\\[\\s*'(([^'\\\\]|\\\\([\"'\\\\\\/bfnrt]|x[0-9a-f]{2}|u[0-9a-f]{4}))*)'\\s*\\]/i\n  const dblquotedIndexPattern = /^\\s*\\[\\s*\"(([^\"\\\\]|\\\\([\"'\\\\\\/bfnrt]|x[0-9a-f]{2}|u[0-9a-f]{4}))*)\"\\s*\\]/i\n\n  function parsedAccessPathFromVisual (\n    Visual:RSC_Visual, literalPath:string\n  ):RSC_AccessPath {\n    const SplitIndex = literalPath.indexOf(':observed')\n    if (SplitIndex < 0) throwError(\n      'InvalidAccessPath:invalid access path ' + quoted(literalPath)\n    )\n\n    let Selector = literalPath.slice(0,SplitIndex)\n    if (ValueIsName(Selector)) {\n      const normalizedName = Selector.toLowerCase()\n      Selector = `rsc-${normalizedName},[behaviour=\"${normalizedName}\"]`\n    }\n\n    let Base = closestVisualMatching(Visual,Selector)\n    if (Base == null) throwError(\n      'NoSuchVisual:could not find a close visual matching CSS selector' +\n      quoted(Selector)\n    )\n\n    let AccessPath = literalPath.slice(SplitIndex + 9).trim()\n\n    const PathList:string[] = []; let Match\n    while (AccessPath !== '') {\n      switch (true) {\n        case (Match =   dottedIndexPattern.exec(AccessPath)) != null:\n        case (Match = unquotedIndexPattern.exec(AccessPath)) != null:\n// @ts-ignore 18048: we know that Match is not null\n          PathList.push(Match[1].trim())\n// @ts-ignore 18048: we know that Match is not null\n          AccessPath = AccessPath.slice(Match[0].length).trim()\n          break\n        case (Match = sglquotedIndexPattern.exec(AccessPath)) != null:\n        case (Match = dblquotedIndexPattern.exec(AccessPath)) != null:\n// @ts-ignore 18048: we know that Match is not null\n          PathList.push(Match[1])\n// @ts-ignore 18048: we know that Match is not null\n          AccessPath = AccessPath.slice(Match[0].length).trim()\n          break\n        default:\n          throwError('InvalidAccessPath:invalid access path ' + quoted(literalPath))\n      }\n    }\n\n    return { Base,PathList }\n  }\n\n/**** ValueOfReactiveVariable ****/\n\n  function ValueOfReactiveVariable (Base:RSC_Visual, PathList:string[]):any {\n    let Value:any = Base.observed[PathList[0]]\n      for (let i = 1, l = PathList.length; i < l; i++) {\n        if (Value == null) throwError(\n          'InvalidAccess:cannot access variable bound to reactive attribute'\n        )\n        Value = Value[PathList[i]]\n      }\n    return Value\n  }\n\n/**** setValueOfReactiveVariable ****/\n\n  function setValueOfReactiveVariable (\n    Base:RSC_Visual, PathList:string[], Value:any\n  ):void {\n    let Variable:Indexable = Base as Indexable\n      for (let i = 0, l = PathList.length-1; i < l; i++) {\n        if (Variable == null) throwError(\n          'InvalidAccess:cannot access variable bound to reactive attribute'\n        )\n        Variable = Variable[PathList[i]]\n      }\n    Variable[PathList[-1]] = Value\n  }\n\n/**** unregisterAllReactiveAttributesOfVisual ****/\n\n  function unregisterAllReactiveAttributesOfVisual (Visual:RSC_Visual):void {\n    let HandlerList:Function[] = reactiveAttributesForVisual.get(Visual) as Function[]\n    if (HandlerList == null) { return }\n\n    HandlerList.forEach((Handler) => {\n      dispose(Handler)\n    })\n  }\n\n/**** registerReactiveFunctionIn ****/\n\n  function registerReactiveFunctionIn (\n    Visual:RSC_Visual, reactiveFunction:Function\n  ):void {\n    let reactiveFunctions = reactiveFunctionsForVisual.get(Visual)\n    if (reactiveFunctions == null) {\n      reactiveFunctionsForVisual.set(Visual,reactiveFunctions = [])\n    }\n    reactiveFunctions.push(reactiveFunction)\n  }\n\n/**** unregisterAllReactiveFunctionsFrom ****/\n\n  function unregisterAllReactiveFunctionsFrom (Visual:RSC_Visual):void {\n    let reactiveFunctions = reactiveFunctionsForVisual.get(Visual)\n    if (reactiveFunctions == null) { return }\n\n    reactiveFunctions.forEach((reactiveFunction) => {\n      dispose(reactiveFunction)\n    })\n  }\n\n//------------------------------------------------------------------------------\n//--                              Error Handling                              --\n//------------------------------------------------------------------------------\n\n  type RSC_ErrorInfo = {\n    Title:Textline,\n    Message:Text\n  }\n\n  const ErrorInfoForVisual:WeakMap<RSC_Visual,RSC_ErrorInfo> = new WeakMap()\n\n/**** setErrorOfVisual ****/\n\n  function setErrorOfVisual (\n    Visual:RSC_Visual, ErrorInfo:RSC_ErrorInfo|undefined\n  ):void {\n    expectErrorInfo('RSC error info record',ErrorInfo)\n\n    if (ErrorInfoForVisual.get(Visual) == null) {\n      ErrorInfoForVisual.set(Visual,ErrorInfo as RSC_ErrorInfo)\n      Visual.render()\n    }\n  }\n\n/**** ErrorOfVisual ****/\n\n  function ErrorOfVisual (Visual:RSC_Visual):RSC_ErrorInfo|undefined {\n    return ErrorInfoForVisual.get(Visual)\n  }\n\n/**** RSC_ErrorIndicator ****/\n\n  function RSC_ErrorIndicator (PropSet:Indexable) {\n    const Visual = PropSet.visual\n\n    function onClick (Event:Event) {\n      showErrorInfoForVisual(Visual)\n    }\n\n    return html`\n      <style>\n        .RSC-ErrorIndicator {\n          display:block; position:absolute; overflow:hidden;\n          left:0px; top:0px; width:24px; height:24px;\n          background:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3Csvg width='24px' height='24px' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M12 17.0001H12.01M12 10.0001V14.0001M6.41209 21.0001H17.588C19.3696 21.0001 20.2604 21.0001 20.783 20.6254C21.2389 20.2985 21.5365 19.7951 21.6033 19.238C21.6798 18.5996 21.2505 17.819 20.3918 16.2579L14.8039 6.09805C13.8897 4.4359 13.4326 3.60482 12.8286 3.32987C12.3022 3.09024 11.6978 3.09024 11.1714 3.32987C10.5674 3.60482 10.1103 4.4359 9.19614 6.09805L3.6082 16.2579C2.74959 17.819 2.32028 18.5996 2.39677 19.238C2.46351 19.7951 2.76116 20.2985 3.21709 20.6254C3.7396 21.0001 4.63043 21.0001 6.41209 21.0001Z' stroke='orange' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' fill='white'/%3E%3C/svg%3E\");\n          pointer-events:auto;\n        }\n      </style>\n      <div class=\"RSC-ErrorIndicator\" onClick=${onClick}></div>\n    `\n  }\n\n/**** showErrorInfoForVisual ****/\n\n  function showErrorInfoForVisual (Visual:RSC_Visual):void {\n    const { Title,Message } = ErrorOfVisual(Visual) as RSC_ErrorInfo\n    window.alert(Title + '\\n\\n' + Message)\n  }\n\n//------------------------------------------------------------------------------\n//--                                RSC_Visual                                --\n//------------------------------------------------------------------------------\n\n  const ShadowRootForVisual:WeakMap<RSC_Visual,any> = new WeakMap()\n\n  const AttributeChangeHandlerForVisual:WeakMap<RSC_Visual,Function> = new WeakMap()\n  const AttachmentHandlerForVisual:WeakMap<RSC_Visual,Function>      = new WeakMap()\n  const DetachmentHandlerForVisual:WeakMap<RSC_Visual,Function>      = new WeakMap()\n  const RendererForVisual:WeakMap<RSC_Visual,Function>               = new WeakMap()\n\n  const DummyHandler = () => {}\n\n  class RSC_Visual extends HTMLElement {\n    static observedAttributes:string[] = ['value']         // may be overwritten\n\n  /**** constructor ****/\n\n    public constructor () {       // already with all attributes and inner nodes\n      super()\n\n      const ShadowRoot = this.attachShadow({ mode:'closed' })\n      ShadowRootForVisual.set(this,ShadowRoot)\n    }\n\n  /**** connectedCallback - elements are added from the outside in ****/\n\n    public connectedCallback () {\n      validateContainerOfVisual(this)    // throws if inacceptable for container\n\n      if (VisualWasInitialized(this)) {\n        unregisterAllReactiveAttributesOfVisual(this)\n        registerAllReactiveAttributesOfVisual(this)\n      } else {\n        registerAllBehavioursFoundInVisual(this)\n        registerAllDelegatedScriptsFoundInVisual(this)\n\n        validateContentsOfVisual(this)\n\n        applyBehaviourScriptOfVisual(this)\n        applyElementScriptOfVisual(this)\n\n        updateAllAttributesOfVisual(this)    // setters should be defined by now\n        registerAllReactiveAttributesOfVisual(this)\n\n        markVisualAsInitialized(this)             // outer visuals are now known\n      }\n\n      startReactiveRenderingOfVisual(this)                   // also renders now\n\n      let AttachmentHandler = AttachmentHandlerForVisual.get(this)\n      if (AttachmentHandler != null) {\n        try {\n          AttachmentHandler.call(this)\n        } catch (Signal) {\n          setErrorOfVisual(this,{\n            Title:'Attachment Handler Failure',\n            Message:'Running the configured attachment handler failed\\n\\n' +\n                    'Reason: ' + Signal\n          })\n        }\n      }\n    }\n\n  /**** disconnectedCallback - elements are removed from the outside in ****/\n\n    public disconnectedCallback () {\n      startReactiveRenderingOfVisual(this)\n\n//    unregisterAllReactiveFunctionsFrom(this) // TODO: better before removal\n      unregisterAllReactiveAttributesOfVisual(this)\n\n      let DetachmentHandler = DetachmentHandlerForVisual.get(this)\n      if (DetachmentHandler != null) {\n        try {\n          DetachmentHandler.call(this)\n        } catch (Signal) {\n          setErrorOfVisual(this,{\n            Title:'Detachment Handler Failure',\n            Message:'Running the configured detachment handler failed\\n\\n' +\n                    'Reason: ' + Signal\n          })\n        }\n      }\n    }\n\n  /**** attributeChangedCallback ****/\n\n    public attributeChangedCallback (\n      normalizedName:string, oldValue:string, newValue:string\n    ) {\n      if (VisualWasInitialized(this) && ! ValueIsReactiveAttributeName(normalizedName)) {\n        updateAttributeOfVisual(this, normalizedName, newValue)\n      }\n    }\n\n  /**** observed ****/\n\n    public get observed ():Indexable  { return ObservableOfVisual(this) }\n    public set observed (_:Indexable) { throwReadOnlyError('observable') }\n\n  /**** unobserved ****/\n\n    public get unobserved ():Indexable  { return UnobservedOfVisual(this) }\n    public set unobserved (_:Indexable) { throwReadOnlyError('unobserved') }\n\n  /**** onAttributeChange (originalName, newValue) ****/\n\n    public onAttributeChange (newHandler:Function):void {\n      expectFunction('visual attribute change handler',newHandler)\n      AttributeChangeHandlerForVisual.set(this,newHandler)\n    }\n\n  /**** onAttachment () ****/\n\n    public onAttachment (newHandler:Function):void {\n      expectFunction('visual attachment handler',newHandler)\n      AttachmentHandlerForVisual.set(this,newHandler)\n    }\n\n  /**** onDetachment () ****/\n\n    public onDetachment (newHandler:Function):void {\n      expectFunction('visual detachment handler',newHandler)\n      DetachmentHandlerForVisual.set(this,newHandler) || DummyHandler\n    }\n\n  /**** Renderer ****/\n\n    public toRender (newHandler:Function) {\n      expectFunction('visual renderer',newHandler)\n      RendererForVisual.set(this,newHandler)\n    }\n\n  /**** render ****/\n\n    public render ():void {\n      if (VisualWasInitialized(this)) {\n        let Rendering\n        if (! this.hasError) {\n          const Renderer = RendererForVisual.get(this)\n          if (Renderer == null) {\n            if (this.tagName === 'RSC-VISUAL') {\n              Rendering = html`${this.observed['Value']}<slot/>`\n            }\n          } else {\n            try {\n              Rendering = Renderer.call(this)\n            } catch (Signal) {\n              setErrorOfVisual(this,{\n                Title:'Rendering Failure',\n                Message:'Running the configured renderer failed, reason: ' + Signal\n              })\n            }\n          }\n        }\n\n        const ShadowRoot = ShadowRootForVisual.get(this)\n        if (this.hasError) {\n          render(html`<${RSC_ErrorIndicator} visual=${this}/>`,ShadowRoot)\n        } else {\n          render(html`${Rendering}`,ShadowRoot)\n        }\n      }\n    }\n\n  /**** hasError ****/\n\n    public get hasError ():boolean  { return (this.Error != null) }\n    public set hasError (_:boolean) { throwReadOnlyError('hasError') }\n\n  /**** Error ****/\n\n    public get Error ():RSC_ErrorInfo|undefined {\n      return ErrorOfVisual(this)\n    }\n    public set Error (ErrorInfo:RSC_ErrorInfo|undefined) {\n      setErrorOfVisual(this,ErrorInfo)\n    }\n  }\n\n  customElements.define('rsc-visual', RSC_Visual)\n\n  registerAllBehavioursFoundInHead()\n}\n"],"names":["observe","computed","dispose","hyperactiv","Stylesheet","document","createElement","RSC","innerHTML","head","appendChild","throwReadOnlyError","Name","throwError","quoted","ValueIsDOMElement","Value","Element","ValueIsVisual","RSC_Visual","allowDOMElement","ValidatorForClassifier","acceptNil","allowedDOMElement","expectDOMElement","rejectNil","expectedDOMElement","allowVisual","allowedVisual","expectVisual","expectedVisual","RSC_NamePattern","ValueIsName","ValueIsStringMatching","ValueIsErrorInfo","ValueIsObject","ValueIsTextline","Title","ValueIsText","Message","allowName","allowedName","expectName","expectedName","allowErrorInfo","allowedErrorInfo","expectErrorInfo","expectedErrorInfo","acceptableBoolean","Default","ValueIsBoolean","acceptableNumber","ValueIsNumber","acceptableNumberInRange","minValue","Infinity","maxValue","withMin","withMax","ValueIsNumberInRange","acceptableInteger","ValueIsInteger","acceptableIntegerInRange","ValueIsIntegerInRange","acceptableString","ValueIsString","acceptableNonEmptyString","trim","acceptableStringMatching","Pattern","acceptableURL","ValueIsURL","InitializationMarkerForVisual","WeakMap","VisualWasInitialized","Visual","get","outerVisualOf","DOMElement","parentElement","closestVisualMatching","Selector","expectTextline","matches","innerElementsOf","Array","from","children","innerVisualsOf","filter","innerElement","VisualContaining","outermostVisualOf","outermostVisual","closestVisualWithBehaviour","BehaviourName","normalizedName","toLowerCase","BehaviourNameOfVisual","BehaviourRegistry","Object","create","InfoForBehaviour","registerBehaviourFromElement","ScriptElement","getAttribute","Source","observedAttributes","split","ValueIsListSatisfying","SourceOrExecutable","allowListSatisfying","AttributeSet","forEach","map","ValueIsFunction","Executable","BehaviourInfo","compiledScript","Signal","console","error","Error","customizedVisual","_a","customElements","define","registerBehaviour","normalizedBehaviourName","permittedVisualsSelectorWithinBehaviour","permitVisualsWithinBehaviour","forbiddenVisualsSelectorWithinBehaviour","forbidVisualsWithinBehaviour","tagName","slice","value","ScriptDelegationSetForVisual","registerDelegatedScriptFromElement","ScriptDelegationSet","set","registerDelegatedScriptInVisual","expectedTextline","Script","Function","applyExecutable","onAttributeChange","bind","onAttachment","onDetachment","toRender","apply","JIL","html","Events","SelectorOrHandler","DataOrHandler","Handler","registerEventHandlerForVisual","ArgList","prototype","call","arguments","replace","unregisterAllMatchingEventHandlersFromVisual","shift","undefined","EventToTrigger","Arguments","bubbles","ValueIsArray","CustomEvent","cancelable","detail","Event","type","assign","dispatchEvent","EventDetails","Result","reactiveFunction","expectFunction","reactiveFunctions","reactiveFunctionsForVisual","push","registerReactiveFunctionIn","applyElementScriptOfVisual","ScriptOfVisual","ScriptList","i","l","length","Candidate","hasAttribute","ScriptInVisual","setErrorOfVisual","ScriptDelegationInfo","ScriptContainer","delegatedScriptInfoForVisual","RSC_NameWithSelectorPattern","ValueIsEventNameWithSelector","once","Data","actualHandler","target","currentTarget","data","concat","stopImmediatePropagation","preventDefault","EventList","AtIndex","indexOf","EventRegistry","EventRegistryForVisual","EntriesForEvent","EntriesForSelector","addEventListener","_registerEventHandlerForVisual","unregisterMatchingEventHandlersFromVisual","unregisterMatchingEventSelectorHandlersFromVisual","ObjectIsEmpty","removeEventListener","every","Index","splice","reactiveAttributesForVisual","ObservableForVisual","UnobservedForVisual","reactiveRendererForVisual","startReactiveRenderingOfVisual","render","ValueIsReactiveAttributeName","startsWith","updateAttributeOfVisual","newValue","AttributeChangeHandler","AttributeChangeHandlerForVisual","Behaviour","originalName","observed","registerAllReactiveAttributesOfVisual","attributes","Attribute","reactiveName","name","Base","PathList","literalPath","SplitIndex","AccessPath","Match","dottedIndexPattern","exec","unquotedIndexPattern","sglquotedIndexPattern","dblquotedIndexPattern","parsedAccessPathFromVisual","HandlerList","Variable","setValueOfReactiveVariable","ValueOfReactiveVariable","unregisterAllReactiveAttributesOfVisual","ErrorInfoForVisual","ErrorInfo","ErrorOfVisual","RSC_ErrorIndicator","PropSet","visual","window","alert","showErrorInfoForVisual","ShadowRootForVisual","AttachmentHandlerForVisual","DetachmentHandlerForVisual","RendererForVisual","HTMLElement","constructor","super","ShadowRoot","this","attachShadow","mode","connectedCallback","Container","permittedVisualsSelector","forbiddenVisualsSelector","validateContainerOfVisual","registerAllDelegatedScriptsFoundInVisual","innerVisual","remove","validateContentsOfVisual","applyBehaviourScriptOfVisual","updateAllAttributesOfVisual","markVisualAsInitialized","AttachmentHandler","disconnectedCallback","DetachmentHandler","attributeChangedCallback","oldValue","Observable","deep","ObservableOfVisual","_","unobserved","Unobserved","UnobservedOfVisual","newHandler","Rendering","hasError","Renderer"],"mappings":"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"}